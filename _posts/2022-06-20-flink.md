---
layout: post
title:  "flink问与答"
author: "marcelyz"
---

## 一、算子相关
- 问：在 flink sql 中， join 都包含哪些类型？（引擎层的实现）<br/>
答：在join中包含 Regular join、Interval join、Temporal join、 lookup join；Regular join 包含 left join、right join、 inner join、 full join；Interval join 时间区间 join, 表示两条流之间 一段时间的join.

- 问：window的几种类型<br/>
答：

- 问：Flink状态<br/>
答：

- 问：Flink广播流<br/>
答：

- 问：watermark是干什么的，如何使用<br/>
答：

## 二、概念相关
- 问：flink各种graph的生成逻辑<br/>
答：一共涉及四个graph，StreamGraph、JobGraph、ExecutionGraph和物理执行图；首先在client端根据用户代码生成StreamGraph，表示最初的拓扑结构；然后做一些优化，比如operator chain 等，减少网络shuffle的开销，生成JobGraph，提交给JobManager；JM根据JobGraph生成ExecutionGraph，是用来调度的执行图，可以看作是并行化版本的 JobGraph，将 DAG 拆分到基本的调度单元。最后JobManager根据生成的ExecutionGraph对Job进行调度后，在各个TM上部署Task后形成一张虚拟图，即物理执行图。

- 问：TaskManager主要作用<br/>
答：4大块；1. slot的资源管理，分配与释放；2. task运行，接收来自JM的taks提交，也包括task对应的partition中间结果信息； 3. checkpoint相关的处理； 4. 心跳检测，练级建立等。


## 三、原理相关
- 问：checekpoint失败又遇到过吗？原因是啥，怎么解决的<br/>
答：少数情况是因为网络问题，很快能恢复；大部分是因为反压导致，当存在反压时，barrier 需要在 buffer 中流动数个小时，从而导致 checkpoint 执行时间过长，超过了 timeout 还没有完成，从而导致失败。主要通过三个操作缓解，首先一致性语义从exactly-once改成at-least-once，在做checkpoint的过程中，buffer不需要对齐；其次将集群迁移至含有nvme磁盘的机房，对rocksdb有很大优化，ckp稳定性和效率都得到很大提升。最后对join的key做优化，从用户id改成点击id，数据倾斜大幅度缓解，state大小缩小60%。checkpoint耗时从10min缩短为30s左右。

- 问：flink和sparkStreaming的区别<br/>
答：

- 问：flink批处理和实时处理有什么关系<br/>
答：

- 问：Flink 精确一致怎么保证<br/>
答：

- 问：Flink 写入redis怎么保证精准一次<br/>
答：