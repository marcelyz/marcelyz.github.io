---
layout: post
title:  "data"
author: "_marcelyz"
---

- 问：sql优化策略<br/>
答：分为两种，RBO(Rule-Based Optimization)和CBO(Cost-Based Optimization)。RBO指基于规则的优化器，包含谓词下推、Join 优化、列裁剪，分区裁剪、常量合并等。但是RBO规则是人为定死的，与数据量级无关，实际开发中数据是变化的，所以RBO生成的执行计划往往不是最优的。CBO指基于代价的优化器，根据数据库对象的统计信息和代价模型计算各种可能执行计划的代价，从中选择代价最低的执行计划，目前各种大数据存储和计算引擎都倾向于使用CBO，spark从2.2版本也开始引入，不过CBO也是一种静态的优化策略，spark 3.0后面又引入了类似AQE的动态优化策略。

- 问：分区裁剪主要解决什么问题<br/>
答：分区剪裁就是对于分区表或者分区索引来说，优化器可以自动从 from 和 where 中根据分区键直接提取出需要访问的分区，从而避免扫描所有的分区，降低了 IO 请求。分区剪裁可以细分为静态分区剪裁和动态分区剪裁，其中静态分区剪裁发生在 sql 语句编译阶段，而动态分区剪裁则发生在 sql 语句执行阶段，对于分区键是常量值优化器在会走静态分区剪裁的，如果分区键是变量形式优化器只会走动态分区剪裁。

- 问：hdfs写数据过程，写的过程中有哪些故障，分别会怎么处理？<br/>
答：首先client创建文件输出流对象，并与NameNode进行一次RPC远程调用，返回每个块需要的DataNode地址信息。然后将数据包以流式传输的方式分配给DataNode，最后在client端调用close方法完成数据写入，并使用complete方法通知NameNode文件写入成功，并将相关信息写入到editlog中。
一般有可能在DataNode写入的时候出现故障，这个时候会存储一个标识，回传给NameNode，方便在恢复后删除出问题的数据块。

- 问：hdfs的数据一致性和租约管理<br/>
答：采用数据校验和checksum机制，收到数据后进行校验，保证一致性。每一个客户端必须获得namenode发放的一个租约，才能进行写入，有效防止多人写入一个文件的情况。

- 问：说下raft、zab和paxos<br/>
答：这三者都是分布式系统的共识算法，Raft相对比较好理解，分为3个子问题，领袖选择(Leader Election)；记录复写(Log Replication)；安全性(Safety)。一个partition会有多个replica，raft确保每个replica数据强一致。  
领袖选举：raft中一个节点会处于三种状态之一：leader、follower、candidate；通过心跳等信息发起选择流程，确定leader。  
记录复写：相同的初始状态+相同的输入=相同的结束状态；通过记录复写log，持久性和有序，保证一致性。  
安全性：保证只有一个leader被选出，不会出现脑裂等问题。  

- 问：2pc和3pc<br/>
答：2pc是为了使分布式系统架构下所有节点在进行事务处理过程中能够保证原子性和一致性设计的算法。数据被分成多个partitions来存储，2pc用来确保多个partition参与的分布式事务正确性。有两个对象，参与者和协调者，两个阶段，投票阶段和提交阶段。算法思路可以概括为参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情况决定各参与者是否要提交操作还是终止操作。以flink的两阶段算子接口为例，投票阶段对应于checkpoint中的snapshot过程，提交阶段对应checkpoint的notify过程。

- 问：稀疏索引和稠密索引  
答：稠密索引是每条数据都存一个索引，稀疏索引是跳跃式地隔着固定一段距离再存下一个key。稀疏索引需要的空间小，占用内存少，但是查询次数多，速度慢。稠密索引占用空间大，但是查询次数少，速度快。(要么时间换空间，要么空间换时间)。kafka存放segement数据段就是采用稀疏索引，针对一个topic下的partition物理文件做分区，每个partition内部又分为多个segement，segement内部存储的一条条message，通过offset在指定partition的segements中的起始位置做二分查找。最终定位到具体的segement，找到上一次消费的位置。  
Mysql Innodb引擎的聚簇索引是稠密索引，非聚簇索引是稀疏索引，Innodb主键索引是与数据存在一起的，所以通过稠密索引，找到叶子节点就可以找到目标数据。  

- 问：列存和行存的比较  
写入性能：行存一次写入，性能更高；列存拆分成单列写入，性能低。  
读性能：读少数几列时，行存需遍历其他无关列，IO开销大，性能低，列存性能高；读整行数据时，行存依次顺序读取，性能高，列存需读取所有列，并拼接成行，性能低。  
数据压缩：行存压缩率低，列存压缩率高。  