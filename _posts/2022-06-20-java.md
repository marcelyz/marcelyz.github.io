---
layout: post
title:  "java问与答"
author: "marcelyz"
---

## 一、常见问题

- **多线程、实现类、线程池、拒绝策略、阻塞队列**  
多线程：是Java最基本的一种并发模型，一个Java程序实际上就是一个JVM进程，JVM进程用一个主线程来执行main方法，在main方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。  
实现类：有好几种，通过继承Thread类重写run方法；通过实现Runnable接口重写run方法；通过实现Callable接口重写call方法，返回一个Future对象表示任务的执行情况(是否完成、执行结果等)。  
线程池：按照线程数量可以分为固定数量的和可变数量的；按照执行时间可以分为立即执行的和延迟执行的。这几种线程池都是基于ThreadPoolExecutor类进行创建的，该类的构造方法有7个参数，可以实现不同类型的线程池。阿里java开发手册强制要求使用ThreadPoolExecutor来自定义线程池，不使用内置的，避免资源耗尽。  
拒绝策略：如果线程池中的线程数据等于maximumPoolSize，就用RejectedExecutionHandler来执行拒绝策略。比如将任务回退给调用者(CallerRunsPolicy)；终止策略(AbortPolicy)；丢弃任务(DiscardPolicy)；抛弃队列中等待最久的任务(DiscardOldestPolicy)。  
阻塞队列：阻塞队列会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒。在生产者消费者模式下也经常用到阻塞队列。  

- **HashMap和ConcurrentHashMap的区别**  
HashMap：非线程安全，底层数据结构是数组+链表/红黑树。当数组长度超过8时，采用红黑树的结构，查询的时间复杂度会降低至O(logN)。  
ConcurrentHashMap：线程安全，数据结构与HashMap类似；JDK7使用ReentrantLock+CAS+分段思想来保证并发安全，但是segment的个数一旦初始化后就不能改变，默认16个，也就是说最多支持16个线程并发；JDK8取消了分段设计，直接使用Node数组来保存数据；使用Synchronized+CAS来保证并发安全，且只锁定当前链表或者红黑树的首节点，提升效率。  

- **JVM GC和常见GC算法**  
简介：JVM GC只回收堆和方法区内的对象；任何GC算法在执行GC时都会发生stop-the-world，此时除了GC所需的线程外，其他所有的线程都进入等待状态。  
GC算法：
    1. 引用计数法：给对象添加引用计数，有引用计数器加1，引用失效减1，容易实现，但是无法检测出循环引用，主流java虚拟机上基本不选用该方法。
    2. 根搜索算法：扫描GC root找到所有引用节点，回收剩余节点。
    3. 标记-清除算法：对存活的对象进行标记，回收未标记的对象，可能存在内存碎片。
    4. 复制算法：将内存划分为活动区间和空闲区间，存活对象复制到空闲区间，回收活动区间。在存活对象少的时候非常高效，但是会浪费50%内存。
    5. 标记-整理算法：跟标记-清除算法类似，另外进行了对象的移动排序整理，解决了内存碎片的问题。  
<br>

- **对比下CMS和G1垃圾回收器**  
CMS：全称是Concurrent Low Pause Collector，是一个老年代收集器，属于标记-清除算法，并行用两次短暂的暂停来代替标记-清除算法的长暂停，响应速度快。不过会存在内存碎片，而且并行操作需要更多的cpu资源。  
G1：全称是GarbageFirst，优先处理那些垃圾多的内存块的意思，既可以回收新生代也可以回收老年代。通过重新划分内存区域，虽然也是Edwn、Survivor、Old区域，但会把内存划分成很多小块，从而使gc更彻底地并行化；进行内存压缩整理的代价比较小，可以规避内存碎片问题，同时兼顾吞吐量和响应时间。因为对内存操作比较多，因此G1比较适合内存稍大一点的应用(至少4G以上)。  

- **为什么复制算法不能用到老年代，新生代可以用**  
答：因为新生代里绝大部分是垃圾对象，可以使用复制算法将小部分存活对象复制到另一区域，然后留下来的都是垃圾对象，可以一下子清除掉。存活的对象少，所以复制的次数也少。但是老年代里大部分是存活对象，复制的代价太大，所以老年代适合使用标记-清除算法，不适合使用复制算法。  

- **java中各种锁**  
答：锁是多线程中保证线程同步的重要工具，可以避免多线程同时读写共享变量导致的数据不一致问题。有基本的synchronized(锁升级优化)；ReentrantLock可重入锁，比synchronized更安全，不会导致死锁；ReadWriteLock读写锁，只允许一个线程写入，允许多个线程在没有写入时同时读取。按照性质可分为公平锁/非公平锁，乐观锁/悲观锁，独享锁/共享锁，互斥锁/读写锁，可重入锁。按照设计方案可分为自旋锁，偏向锁/轻量级锁/重量级锁，分段锁等。  

- **java内存**  
堆内存(Heap memory)：JVM进程内用于保存Java对象并由JVM垃圾回收器维护的内存。
本机内存/堆外(Native memory/Off-heap)：是在进程地址空间内分配的内存，不在堆内，因此不会被Java垃圾回收器释放。
直接内存：类似于原生内存，但也意味着共享硬件内的底层缓冲区。例如，网络适配器或图形显示器内的缓冲区。这里的目标是减少相同字节在内存中被复制的次数。  

- **java堆内存**  
java的堆内存：分为两个区域，新生代(Young)和老年代(Old)。新生代保存的是生命周期比较短的对象，老年代保存的是生命周期比较长的对象。
新生代：又分为3个区域(Eden、Survivor0、Survivor1)
GC：当Eden区已满时，Eden上会触发minor GC，并将Eden和Survivor0中的对象复制到Survivor1中。如果一个对象足够老，或者Survivor1已满，则会移动到老年代。最后当老年代接近满的时候，会触发full GC，直接进入stop the world，停止java系统所有工作线程。