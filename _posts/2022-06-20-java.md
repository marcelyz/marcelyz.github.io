---
layout: post
title:  "java问与答"
author: "marcelyz"
---

## 一、常见问题

- 问：多线程、实现类、线程池、拒绝策略、阻塞队列<br/>
答：多线程：是Java最基本的一种并发模型，一个Java程序实际上就是一个JVM进程，JVM进程用一个主线程来执行main方法，在main方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。  
实现类：有好几种，通过继承Thread类重写run方法；通过实现Runnable接口重写run方法；通过实现Callable接口重写call方法，返回一个Future对象表示任务的执行情况(是否完成、执行结果等)。  
线程池：按照线程数量可以分为固定数量的和可变数量的；按照执行时间可以分为立即执行的和延迟执行的。这几种线程池都是基于ThreadPoolExecutor类进行创建的，该类的构造方法有7个参数，可以实现不同类型的线程池。阿里java开发手册强制要求使用ThreadPoolExecutor来自定义线程池，不使用内置的，避免资源耗尽。  
拒绝策略：如果线程池中的线程数据等于maximumPoolSize，就用RejectedExecutionHandler来执行拒绝策略。比如将任务回退给调用者(CallerRunsPolicy)；终止策略(AbortPolicy)；丢弃任务(DiscardPolicy)；抛弃队列中等待最久的任务(DiscardOldestPolicy)。  
阻塞队列：阻塞队列会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒。在生产者消费者模式下也经常用到阻塞队列。  

- 问：聊聊hashmap和concurenthashmap的区别和细节<br/>
答：

- 问：简单聊下JVM GC  
简介：JVM GC只回收堆和方法区内的对象，任何GC算法在执行GC时都会发生stop-the-world，此时除了GC所需的线程外，其他所有的线程都进入等待状态。  
GC算法：
    1. 根搜索算法：扫描GC root找到所有引用节点，回收剩余节点。
    2. 标记-清除算法：对存活的对象进行标记，回收未标记的对象，可能存在内存碎片。
    3. 复制算法：将内存划分为活动区间和空闲区间，存活对象复制到空闲区间，回收活动区间。在存活对象少的时候非常高效，但是会浪费50%内存。
    4. 标记-整理算法：跟标记-清除算法类似，另外进行了对象的移动排序整理，解决了内存碎片的问题。  
<br>

- 问：对比下CMS和G1垃圾回收器<br/>
CMS：全称是Concurrent Low Pause Collector，是一个老年代收集器，并行用两次短暂的暂停来代替标记-清除算法的长暂停，响应速度快。不过会存在内存碎片，而且并行操作需要更多的cpu资源。  
G1：全称是GarbageFirst，既可以回收新生代也可以回收老年代。通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间。  

- 问：为什么复制算法不能用到老年代，新生代可以用<br/>
答：因为新生代里绝大部分是垃圾对象，可以使用复制算法将小部分存活对象复制到另一区域，然后留下来的都是垃圾对象，可以一下子清除掉。存活的对象少，所以复制的次数也少。但是老年代里大部分是存活对象，复制的代价太大，所以老年代适合使用标记-清除算法，不适合使用复制算法。  

- 问：java中各种锁<br>
答：锁是多线程中保证线程同步的重要工具，可以避免多线程同时读写共享变量导致的数据不一致问题。有基本的synchronized重锁；ReentrantLock可重入锁，比synchronized更安全，不会导致死锁；ReadWriteLock读写锁，只允许一个线程写入，允许多个线程在没有写入时同时读取。按照性质可分为公平锁/非公平锁，乐观锁/悲观锁，独享所/共享锁，互斥锁/读写锁，可重入锁。按照设计方案可分为自旋锁，偏向锁/轻量级锁/重量级锁，分段锁等。  

- 问：java内存<br>
* 堆内存(Heap memory)：JVM 进程内用于保存 Java 对象并由 JVM 垃圾收集器维护的内存。
* 本机内存/堆外(Native memory/Off-heap)：是在进程地址空间内分配的内存，不在堆内，因此不会被Java垃圾收集器释放。
* 直接内存()：类似于原生内存，但也意味着共享硬件内的底层缓冲区。例如，网络适配器或图形显示器内的缓冲区。这里的目标是减少相同字节在内存中被复制的次数。

- 问：java堆内存<br>
* java的堆内存：分为两个区域，新生代(Young)和老年代(Old)。新生代保存的是生命周期比较短的对象，老年代保存的是生命周期比较长的对象。
* 新生代：又分为3个区域(Eden、Survivor0、Survivor1)
* GC：当Eden区已满时，Eden上会触发minor GC，并将Eden和Survivor0中的对象复制到Survivor1中。如果一个对象足够老，或者Survivor1已满，则会移动到老年代。最后当老年代接近满的时候，会触发full GC，直接进入stop the world，停止java系统所有工作线程。