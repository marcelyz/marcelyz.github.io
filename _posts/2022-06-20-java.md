---
layout: post
title:  "java问与答"
author: "marcelyz"
---

## 一、常见问题

- 问：多线程、实现类、线程池、拒绝策略、阻塞队列<br/>
答：多线程：是Java最基本的一种并发模型，一个Java程序实际上就是一个JVM进程，JVM进程用一个主线程来执行main方法，在main方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。  
实现类：有好几种，通过继承Thread类重写run方法；通过实现Runnable接口重写run方法；通过实现Callable接口重写call方法，返回一个Future对象表示任务的执行情况(是否完成、执行结果等)。  
线程池：按照线程数量可以分为固定数量的和可变数量的；按照执行时间可以分为立即执行的和延迟执行的。这几种线程池都是基于ThreadPoolExecutor类进行创建的，该类的构造方法有7个参数，可以实现不同类型的线程池。阿里java开发手册强制要求使用ThreadPoolExecutor来自定义线程池，不使用内置的，避免资源耗尽。  
拒绝策略：如果线程池中的线程数据等于maximumPoolSize，就用RejectedExecutionHandler来执行拒绝策略。比如将任务回退给调用者(CallerRunsPolicy)；终止策略(AbortPolicy)；丢弃任务(DiscardPolicy)；抛弃队列中等待最久的任务(DiscardOldestPolicy)。  
阻塞队列：阻塞队列会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒。在生产者消费者模式下也经常用到阻塞队列。  

- 问：聊聊hashmap和concurenthashmap的区别和细节<br/>
答：

- 问：说下G1垃圾回收器的原理<br/>
答：

- 问：说下JVM中复制算法和标记清除算法、标记整理算法的区别，你分析下为什么复制算法不能用到老年代，有啥问题等<br/>
答：

- 问：java中各种锁<br>
答：

- 问：java内存<br>
* 堆内存(Heap memory)：JVM 进程内用于保存 Java 对象并由 JVM 垃圾收集器维护的内存。
* 本机内存/堆外(Native memory/Off-heap)：是在进程地址空间内分配的内存，不在堆内，因此不会被Java垃圾收集器释放。
* 直接内存()：类似于原生内存，但也意味着共享硬件内的底层缓冲区。例如，网络适配器或图形显示器内的缓冲区。这里的目标是减少相同字节在内存中被复制的次数。

- 问：java堆内存<br>
* java的堆内存：分为两个区域，新生代(Young)和老年代(Old)。新生代保存的是生命周期比较短的对象，老年代保存的是生命周期比较长的对象。
* 新生代：又分为3个区域(Eden、Survivor0、Survivor1)
* GC：当Eden区已满时，Eden上会触发minor GC，并将Eden和Survivor0中的对象复制到Survivor1中。如果一个对象足够老，或者Survivor1已满，则会移动到老年代。最后当老年代接近满的时候，会触发full GC，直接进入stop the world，停止java系统所有工作线程。